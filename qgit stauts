[1mdiff --git a/src/gamecharacters/AbstractCard.ts b/src/gamecharacters/AbstractCard.ts[m
[1mindex 6790120..8415b79 100644[m
[1m--- a/src/gamecharacters/AbstractCard.ts[m
[1m+++ b/src/gamecharacters/AbstractCard.ts[m
[36m@@ -234,7 +234,7 @@[m [mexport abstract class AbstractCard implements IAbstractCard {[m
             return canonicalCard as any as this;[m
         }[m
         // check for card in inventory[m
[31m-        const inventory = GameState.getInstance().inventory;[m
[32m+[m[32m        const inventory = GameState.getInstance().cardsInventory;[m
         const canonicalCardInInventory = inventory.find((card: AbstractCard) => card.id === this.id);[m
         if (canonicalCardInInventory) {[m
             return canonicalCardInInventory as any as this;[m
[1mdiff --git a/src/relics/AbstractRelic.ts b/src/relics/AbstractRelic.ts[m
[1mindex 19cad9b..93f4851 100644[m
[1m--- a/src/relics/AbstractRelic.ts[m
[1m+++ b/src/relics/AbstractRelic.ts[m
[36m@@ -8,6 +8,8 @@[m [mexport abstract class AbstractRelic {[m
     name!: string;[m
     description!: string;[m
     tier!: CardRarity;[m
[32m+[m[32m    price!: number;[m
[32m+[m[32m    portraitName!: string;[m
 [m
     constructor() {[m
     }[m
[1mdiff --git a/src/rules/GameState.ts b/src/rules/GameState.ts[m
[1mindex 39547d4..dd02901 100644[m
[1m--- a/src/rules/GameState.ts[m
[1m+++ b/src/rules/GameState.ts[m
[36m@@ -2,6 +2,7 @@[m [mimport type { AbstractCard } from '../gamecharacters/AbstractCard';[m
 import type { PlayerCharacter } from '../gamecharacters/CharacterClasses';[m
 import type { PlayableCard } from '../gamecharacters/PlayableCard';[m
 import type { LocationCard } from '../maplogic/LocationCard';[m
[32m+[m[32mimport { AbstractRelic } from '../relics/AbstractRelic';[m
 import type { AutomatedCharacterType, BaseCharacterType } from '../Types';[m
 import type { PhysicalCard } from '../ui/PhysicalCard';[m
 export class GameState {[m
[36m@@ -10,7 +11,8 @@[m [mexport class GameState {[m
     public roster: PlayerCharacter[] = [];[m
     public currentRunCharacters: PlayerCharacter[] = [];[m
     public shopItems: PlayableCard[] = [];[m
[31m-    public inventory: PlayableCard[] = [];[m
[32m+[m[32m    public cardsInventory: PlayableCard[] = [];[m
[32m+[m[32m    public relicsInventory: AbstractRelic[] = [];[m
 [m
     public surfaceCurrency: number = 0[m
     public hellCurrency: number = 0[m
[36m@@ -32,7 +34,7 @@[m [mexport class GameState {[m
     }[m
 [m
     public getCardsOwnedByCharacter(character: PlayerCharacter): PlayableCard[]{[m
[31m-        const inventoryCards = this.inventory.filter(card => card.owner?.id === character.id)[m
[32m+[m[32m        const inventoryCards = this.cardsInventory.filter(card => card.owner?.id === character.id)[m
         const currentCharacter = this.currentRunCharacters.filter(card => card.id === character.id)[m
         const currentCharacterCards = currentCharacter.flatMap(c => c.cardsInMasterDeck)[m
         return [...inventoryCards, ...currentCharacterCards][m
[36m@@ -60,7 +62,7 @@[m [mexport class GameState {[m
         // If you need to handle enemy characters, ensure CombatState has this property[m
         // this.obliteratePhysicalCardsForArray(this.combatState.enemyCharacters);[m
 [m
[31m-        this.obliteratePhysicalCardsForArray(this.inventory);[m
[32m+[m[32m        this.obliteratePhysicalCardsForArray(this.cardsInventory);[m
     }[m
 [m
     // Roster methods[m
[36m@@ -100,16 +102,16 @@[m [mexport class GameState {[m
 [m
     // Inventory methods[m
     public addToInventory(item: PlayableCard): void {[m
[31m-        this.inventory.push(item);[m
[32m+[m[32m        this.cardsInventory.push(item);[m
         // Optionally, update UI or perform additional actions[m
     }[m
 [m
     public removeFromInventory(item: PlayableCard): void {[m
[31m-        this.inventory = this.inventory.filter(i => i !== item);[m
[32m+[m[32m        this.cardsInventory = this.cardsInventory.filter(i => i !== item);[m
     }[m
 [m
     public getInventory(): PlayableCard[] {[m
[31m-        return [...this.inventory];[m
[32m+[m[32m        return [...this.cardsInventory];[m
     }[m
 [m
     // Reset method[m
[36m@@ -117,7 +119,7 @@[m [mexport class GameState {[m
         this.roster = [];[m
         this.currentRunCharacters = [];[m
         this.shopItems = [];[m
[31m-        this.inventory = [];[m
[32m+[m[32m        this.cardsInventory = [];[m
     }[m
 [m
     // Serializer function[m
[36m@@ -132,7 +134,7 @@[m [mexport class GameState {[m
                 ...char[m
             })),[m
             shopItems: this.shopItems,[m
[31m-            inventory: this.inventory[m
[32m+[m[32m            inventory: this.cardsInventory[m
         };[m
         return JSON.stringify(serializableState);[m
     }[m
[1mdiff --git a/src/rules/combatrules.ts b/src/rules/combatrules.ts[m
[1mindex ef129bd..ec0a5e9 100644[m
[1m--- a/src/rules/combatrules.ts[m
[1m+++ b/src/rules/combatrules.ts[m
[36m@@ -10,9 +10,9 @@[m [mexport class DamageCalculationResult {[m
     unblockedDamage: number;[m
 [m
     constructor(totalDamage: number, blockedDamage: number, unblockedDamage: number) {[m
[31m-        this.totalDamage = totalDamage;[m
[31m-        this.blockedDamage = blockedDamage;[m
[31m-        this.unblockedDamage = unblockedDamage;[m
[32m+[m[32m        this.totalDamage = Math.round(totalDamage);[m
[32m+[m[32m        this.blockedDamage = Math.round(blockedDamage);[m
[32m+[m[32m        this.unblockedDamage = Math.round(unblockedDamage);[m
     }[m
 }[m
 [m
[1mdiff --git a/src/screens/subcomponents/ShopOverlay.ts b/src/screens/subcomponents/ShopOverlay.ts[m
[1mindex 2194bb5..ba57b7e 100644[m
[1m--- a/src/screens/subcomponents/ShopOverlay.ts[m
[1m+++ b/src/screens/subcomponents/ShopOverlay.ts[m
[36m@@ -10,7 +10,8 @@[m [mimport { FrozenDew } from '../../relics/common/FrozenDew';[m
 import { IronFilings } from '../../relics/common/IronFilings';[m
 import { GameState } from '../../rules/GameState';[m
 import { DepthManager } from '../../ui/DepthManager';[m
[31m-import { ShopItemPanel } from '../../ui/ShopItemPanel';[m
[32m+[m[32mimport { ShopCardPanel } from '../../ui/ShopCardPanel';[m
[32m+[m[32mimport { ShopRelicPanel } from '../../ui/ShopRelicPanel';[m
 import { TextBox } from '../../ui/TextBox';[m
 import { UIContext, UIContextManager } from '../../ui/UIContextManager';[m
 import { ActionManagerFetcher } from '../../utils/ActionManagerFetcher';[m
[36m@@ -22,8 +23,9 @@[m [mexport class ShopOverlay {[m
     private isVisible: boolean = false;[m
     private shopItemsContainer!: Phaser.GameObjects.Container;[m
     private inventoryContainer!: Phaser.GameObjects.Container;[m
[31m-    private shopItemPanels: ShopItemPanel[] = [];[m
[31m-    private inventoryItemPanels: ShopItemPanel[] = [];[m
[32m+[m[32m    private shopItemPanels: ShopCardPanel[] = [];[m
[32m+[m[32m    private inventoryItemPanels: ShopCardPanel[] = [];[m
[32m+[m[32m    private shopRelicPanels: ShopRelicPanel[] = [];[m
     private readonly BASE_PANEL_DEPTH = DepthManager.getInstance().SHOP_OVERLAY;[m
     private campaignBriefStatus: CampaignBriefStatus;[m
     private shopCards: PlayableCard[] = [new Rummage(), new Rummage(), new Rummage()];[m
[36m@@ -80,34 +82,32 @@[m [mexport class ShopOverlay {[m
         const verticalSpacing = 250;[m
         const horizontalSpacing = 200;[m
         const startX = 50;[m
[31m-        // Position relics below the cards[m
[31m-        const startY = 850; // Adjust this value based on your layout needs[m
[32m+[m[32m        const startY = 850;[m
 [m
         this.shopRelics.forEach((relic, index) => {[m
             const row = Math.floor(index / gridColumns);[m
             const col = index % gridColumns;[m
             [m
[31m-            const panel = new ShopItemPanel([m
[32m+[m[32m            const panel = new ShopRelicPanel([m
                 this.scene,[m
                 startX + col * horizontalSpacing,[m
                 startY + row * verticalSpacing,[m
                 relic,[m
[31m-                true,[m
[31m-                this.buyRelic.bind(this),[m
[31m-                PriceContext.HELL_BUY[m
[32m+[m[32m                PriceContext.HELL_BUY,[m
[32m+[m[32m                this.buyRelic.bind(this)[m
             );[m
             [m
             this.shopItemsContainer.add(panel);[m
             panel.setDepth(this.BASE_PANEL_DEPTH);[m
[31m-            this.shopItemPanels.push(panel);[m
[32m+[m[32m            this.shopRelicPanels.push(panel);[m
         });[m
     }[m
 [m
     private buyRelic(relic: AbstractRelic): void {[m
         console.log(`Buying relic ${relic.name}`);[m
[31m-        if (ActionManagerFetcher.getActionManager().buyItemForHellCurrency(relic)) {[m
[32m+[m[32m        if (ActionManagerFetcher.getActionManager().buyRelicForHellCurrency(relic, relic.price)) {[m
             // Remove the purchased relic from the shop relics array[m
[31m-            const relicIndex = this.shopRelics.findIndex(shopRelic => shopRelic.id === relic.id);[m
[32m+[m[32m            const relicIndex = this.shopRelics.findIndex(shopRelic => shopRelic.name === relic.name);[m
             if (relicIndex !== -1) {[m
                 this.shopRelics.splice(relicIndex, 1);[m
             }[m
[36m@@ -145,7 +145,7 @@[m [mexport class ShopOverlay {[m
                 // Only create a panel if there's an item available[m
                 if (index < shopItems.length) {[m
                     const item = shopItems[index];[m
[31m-                    const panel = new ShopItemPanel([m
[32m+[m[32m                    const panel = new ShopCardPanel([m
                         this.scene, [m
                         startX + col * horizontalSpacing, [m
                         startY + row * verticalSpacing, [m
[36m@@ -164,11 +164,11 @@[m [mexport class ShopOverlay {[m
     }[m
 [m
     private populateSellableInventory(): void {[m
[31m-        const inventory = GameState.getInstance().inventory;[m
[32m+[m[32m        const inventory = GameState.getInstance().cardsInventory;[m
         inventory.forEach((item, index) => {[m
 [m
             if (item.hellSellValue > 0) {[m
[31m-                const panel = new ShopItemPanel(this.scene, 0, index * 200 + 100, item, false, this.sellItem.bind(this), PriceContext.HELL_SELL);[m
[32m+[m[32m                const panel = new ShopCardPanel(this.scene, 0, index * 200 + 100, item, false, this.sellItem.bind(this), PriceContext.HELL_SELL);[m
                 this.inventoryContainer.add(panel); // Changed from panel.container to panel[m
 [m
                 panel.setDepth(this.BASE_PANEL_DEPTH);[m
[36m@@ -244,6 +244,10 @@[m [mexport class ShopOverlay {[m
         this.shopItemsContainer.removeAll(true);[m
         this.inventoryContainer.removeAll(true);[m
 [m
[32m+[m[32m        // Destroy all tracked relic panels[m
[32m+[m[32m        this.shopRelicPanels.forEach(panel => panel.destroy());[m
[32m+[m[32m        this.shopRelicPanels = [];[m
[32m+[m
         // Repopulate with updated items[m
         this.populatePurchasableShopCards();[m
         this.populatePurchasableShopRelics();[m
[1mdiff --git a/src/ui/ShopItemPanel.ts b/src/ui/ShopItemPanel.ts[m
[1mdeleted file mode 100644[m
[1mindex 694537d..0000000[m
[1m--- a/src/ui/ShopItemPanel.ts[m
[1m+++ /dev/null[m
[36m@@ -1,93 +0,0 @@[m
[31m-import Phaser from 'phaser';[m
[31m-import { PriceContext } from '../gamecharacters/AbstractCard';[m
[31m-import { PlayableCard } from '../gamecharacters/PlayableCard';[m
[31m-import { CardGuiUtils } from '../utils/CardGuiUtils';[m
[31m-import { DepthManager } from './DepthManager';[m
[31m-import { PhysicalCard } from './PhysicalCard';[m
[31m-[m
[31m-export class ShopItemPanel extends Phaser.GameObjects.Container {[m
[31m-    private card: PlayableCard;[m
[31m-    private physicalCard!: PhysicalCard;[m
[31m-    private isBuyable: boolean;[m
[31m-[m
[31m-    constructor(scene: Phaser.Scene, x: number, y: number, card: PlayableCard, isBuyable: boolean, onPurchase: (card: PlayableCard) => void, priceContext: PriceContext) {[m
[31m-        super(scene, x, y);[m
[31m-        this.card = card;[m
[31m-        this.isBuyable = isBuyable;[m
[31m-[m
[31m-        this.createPhysicalCard(priceContext);[m
[31m-        this.setupInteractivity(onPurchase);[m
[31m-        this.arrangeComponents();[m
[31m-[m
[31m-        this.scene.add.existing(this);[m
[31m-    }[m
[31m-[m
[31m-    private createPhysicalCard(priceContext: PriceContext): void {[m
[31m-        const cardGuiUtils = CardGuiUtils.getInstance();[m
[31m-        this.physicalCard = cardGuiUtils.createCard({[m
[31m-            scene: this.scene,[m
[31m-            x: 0,[m
[31m-            y: 0,[m
[31m-            data: this.card,[m
[31m-            onCardCreatedEventCallback: () => {}[m
[31m-        });[m
[31m-        this.physicalCard.priceContext = priceContext;[m
[31m-        this.physicalCard.container[m
[31m-            .on('pointerdown', () => this.emit('pointerdown'))[m
[31m-            .on('pointerover', () => this.emit('pointerover'))[m
[31m-            .on('pointerout', () => this.emit('pointerout'));[m
[31m-        this.add(this.physicalCard.container);[m
[31m-    }[m
[31m-[m
[31m-    public destroy(): void {[m
[31m-        if (this.physicalCard) {[m
[31m-            this.physicalCard.obliterate();[m
[31m-            this.physicalCard.destroy();[m
[31m-        }[m
[31m-[m
[31m-        this.removeAll(true);[m
[31m-        super.destroy();[m
[31m-    }[m
[31m-[m
[31m-    public setCardHoverDepth(depth: number): void {[m
[31m-        this.setDepth(depth);[m
[31m-        if (this.physicalCard) {[m
[31m-            this.physicalCard.setDepth(depth);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private setupInteractivity(onPurchase: (card: PlayableCard) => void): void {[m
[31m-        console.log(`setting up interactivity for ${this.card.name}'s shop item panel`);[m
[31m-        this.setInteractive()[m
[31m-            .on('pointerdown', () => {[m
[31m-                console.log(`pointerdown on ${this.card.name}'s shop item panel`);[m
[31m-                onPurchase(this.card);[m
[31m-            })[m
[31m-            .on('pointerover', () => {                [m
[31m-                console.log(`pointerover on ${this.card.name}'s shop item panel`);[m
[31m-                this.setToTop();[m
[31m-                this.setCardHoverDepth(DepthManager.getInstance().SHOP_CARD_HOVER);[m
[31m-            })[m
[31m-            .on('pointerout', () => {[m
[31m-                this.setCardHoverDepth(DepthManager.getInstance().SHOP_OVERLAY);[m
[31m-            });[m
[31m-    }[m
[31m-[m
[31m-    private arrangeComponents(): void {[m
[31m-        // Set the container size to match the physical card[m
[31m-        const width = this.physicalCard.container.width;[m
[31m-        const height = this.physicalCard.container.height;[m
[31m-        this.setSize(width, height);[m
[31m-[m
[31m-        // Update the interactive area[m
[31m-        this.input?.hitArea?.setTo(0, 0, width, height);[m
[31m-    }[m
[31m-[m
[31m-    public onHoverStart(callback: () => void): void {[m
[31m-        this.on('pointerover', callback);[m
[31m-    }[m
[31m-[m
[31m-    public onHoverEnd(callback: () => void): void {[m
[31m-        this.on('pointerout', callback);[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/utils/ActionManager.ts b/src/utils/ActionManager.ts[m
[1mindex 4a538ac..a6c94c2 100644[m
[1m--- a/src/utils/ActionManager.ts[m
[1m+++ b/src/utils/ActionManager.ts[m
[36m@@ -8,6 +8,7 @@[m [mimport { Stress } from "../gamecharacters/buffs/standard/Stress";[m
 import { IBaseCharacter } from "../gamecharacters/IBaseCharacter";[m
 import { PlayableCard } from "../gamecharacters/PlayableCard";[m
 import { ProcBroadcaster } from "../gamecharacters/procs/ProcBroadcaster";[m
[32m+[m[32mimport { AbstractRelic } from "../relics/AbstractRelic";[m
 import { AbstractCombatEvent } from "../rules/AbstractCombatEvent";[m
 import { CombatRules, DamageCalculationResult } from "../rules/CombatRules";[m
 import { DeckLogic, PileName } from "../rules/DeckLogic";[m
[36m@@ -20,7 +21,7 @@[m [mexport class ActionManager {[m
 [m
 [m
     sellItemForHellCurrency(item: PlayableCard) {[m
[31m-        const inventory = GameState.getInstance().inventory;[m
[32m+[m[32m        const inventory = GameState.getInstance().cardsInventory;[m
         const index = inventory.findIndex(card => card.id === item.id);[m
         if (index !== -1) {[m
             inventory.splice(index, 1);[m
[36m@@ -28,9 +29,20 @@[m [mexport class ActionManager {[m
 [m
         GameState.getInstance().hellCurrency += item.hellSellValue;[m
     }[m
[32m+[m[32m    buyRelicForHellCurrency(relic: AbstractRelic, price: number) : boolean {[m
[32m+[m[32m        if (GameState.getInstance().hellCurrency < price) {[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        const inventory = GameState.getInstance().relicsInventory;[m
[32m+[m[32m        inventory.push(relic);[m
[32m+[m[41m        [m
[32m+[m[32m        GameState.getInstance().hellCurrency -= price;[m
[32m+[m[32m        return true;[m
[32m+[m[32m    }[m
[32m+[m
 [m
     buyItemForHellCurrency(item: PlayableCard) : boolean {[m
[31m-        const inventory = GameState.getInstance().inventory;[m
[32m+[m[32m        const inventory = GameState.getInstance().cardsInventory;[m
         if (GameState.getInstance().hellCurrency < item.hellPurchaseValue) {[m
             return false;[m
         }[m
